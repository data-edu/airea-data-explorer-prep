---
title: "prep-data-for-app"
format: html
editor: visual
---

## loading

```{r}
library(tidyverse)
library(haven)
library(arrow)
library(tidycensus)
library(dtplyr)
```

## cz labels

```{r}
sff <- sf::read_sf("prep/CommutingZones2020_County_GIS_files/county20.shp") %>%
  as_tibble() %>%
  select(countycd = GEOID, CZ = CZ20, -geometry) %>%
  mutate(countycd = as.integer(countycd))

city_data <- read_csv("prep/us_cities_over_1000_with_county_fips.csv")

city_data <- city_data %>%
  mutate(countycd = as.integer(county_fips)) %>%
  select(city, countycd, population) %>%
  group_by(countycd) %>%
  slice_max(order_by = population, n = 1, with_ties = FALSE) %>%
  ungroup()

ratio_thresh <- 2      # how many times bigger the top city must be to stand alone
share_thresh <- 0.8    # how big (as a fraction of the top) a city must be to join the label

cz_labels <- city_data %>%
  inner_join(sff, by = "countycd") %>%    # bring in CZ for each county
  group_by(CZ) %>%
  summarise(
    cz_label = {
      df <- cur_data_all() %>% arrange(desc(population))
      if (nrow(df) >= 2 && df$population[1] >= ratio_thresh * df$population[2]) {
        df$city[1]
      } else {
        df$city[df$population >= share_thresh * df$population[1]] %>%
          paste(collapse = " & ")
      }
    },
    .groups = "drop"
  )

county_cz_labels <- sff %>%
  select(countycd, CZ) %>%
  left_join(cz_labels, by = "CZ") %>% 
  rename(county = countycd)

write_csv(county_cz_labels, "county_cz_labels.csv")
```

## supply

```{r}
supply_data <- read_dta("prep/ccrc_cip_comp_aire_6dig.dta")

supply_data <- supply_data %>% 
  select(instnm, inst_id = unitid,
         year, 
         state = State,
         tribal,
         rural,
         cip,
         cip_title,
         county = countycd,
         total_completions = cmplt_tot,
         airea_completions = inst_aire_cmplt_tot)

supply_data <- supply_data %>% 
  mutate(cip_title = str_trim(cip_title))

supply_data <- supply_data %>%
  mutate(county = as.integer(county)) %>% 
  left_join(county_cz_labels)

supply_data <- supply_data %>% 
  select(-CZ, -county)

supply_data %>% 
  arrow::write_parquet("prep/supply.parquet.gzip", compression = "gzip")
```


## map tab supply data prep
```{r}
map_supply_data <- read_dta("prep/ccrc_cip_comp_aire_6dig.dta")

map_supply_data <- map_supply_data %>% 
  select(instnm, inst_id = unitid,
         latitude, longitud,
         year, 
         state = State,
         county = countycd,
         total_completions = cmplt_tot,
         airea_completions = inst_aire_cmplt_tot)

map_supply_data <- map_supply_data %>%
  mutate(county = as.integer(county)) %>% 
  left_join(county_cz_labels)

map_supply_data <- map_supply_data %>% 
  select(-CZ, -county)


map_supply_summary <- map_supply_data %>%
  group_by(year, inst_id, instnm) %>%   
  summarise(
    cz_label  = first(na.omit(cz_label)),
    latitude  = first(na.omit(latitude)),
    longitud  = first(na.omit(longitud)),
    inst_cmplt_tot    = sum(total_completions, na.rm = TRUE),
    airea_completions = sum(airea_completions, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    inst_perc_acea_tot = if_else(inst_cmplt_tot > 0,
                                 airea_completions / inst_cmplt_tot,
                                 NA_real_)
  ) %>%
  arrange(year, instnm)

map_supply_summary %>% 
  arrow::write_parquet("prep/mapsupply.parquet.gzip", compression = "gzip")

```


## demand data

```{r}
demand_data <- read_csv("prep/lightcast-soc-year-county-2025-02-24 7_23pm.csv")

# many are unknown
demand_data <- demand_data %>% 
  filter(!str_detect(COUNTY_NAME, "Unknown"))

demand_data <- demand_data %>% 
  rename(county = COUNTY)

demand_data <- demand_data %>% 
  left_join(county_cz_labels, by = "county") %>% 
  select(-CZ)

demand_meta_data <- read_dta("prep/full_soc.dta")

demand_meta_data <- demand_meta_data %>%
  mutate(aire_ind = as_factor(aire_ind)) %>%  # keep descriptive labels
  mutate(value = 1) %>%                       # mark presence
  pivot_wider(
    names_from = aire_ind, 
    values_from = value, 
    values_fill = list(value = 0)
  ) %>% 
  janitor::clean_names() %>% 
  rename(industry_non_airea = non_aire,
         industry_energy = energy,
         industry_infrastructure = infrastructure,
         industry_ag_nat_resources = agriculture_natural_resources)

demand_data <- demand_data %>% 
  rename(soc = SOC_CODE) %>% 
  left_join(demand_meta_data)

years <- 2010:2023

county_pop_data <- map_dfr(
  years,
  ~ get_acs(
    geography  = "county",
    variables  = "B01003_001",
    year       = .x,
    survey     = "acs5",
    cache_table= TRUE
  ) |>
    mutate(year = .x)
)

county_pop_ts <- county_pop_data %>% 
  select(-moe) %>% 
  select(COUNTY = GEOID, population_estimate = estimate, YEAR = year) %>% 
  rename(county = COUNTY) %>% 
  mutate(county = as.integer(county))

demand_data <- demand_data %>%
  left_join(county_pop_ts, by = c("county", "YEAR"))

demand_data <- demand_data %>% 
  select(county,
         cz_label,
         year = YEAR, 
         soc,
         soc_title = soc2018title, 
         job_posting_count = JOB_POSTING_COUNT,
         ed_req,
         airea = aire_relevant,
         population_estimate,
         contains("industry")
  )

demand_summed_by_cz <- lazy_dt(demand_data) %>%
  group_by(cz_label, year, soc) %>%
  summarise(
    mean_population    = mean(population_estimate, na.rm = TRUE),
    total_job_postings = sum(job_posting_count,   na.rm = TRUE),
    
    # grab first value of each “constant” column
    soc_title                = first(soc_title),
    ed_req                   = first(ed_req),
    airea                    = first(airea),
    across(starts_with("industry_"), first),
    
    .groups = "drop"
  ) %>%
  as_tibble() %>% 
  filter(!is.na(cz_label))

demand_summed_by_cz %>% 
  arrow::write_parquet("prep/demand.parquet.gzip", compression = "gzip")
```


## map demand data prep
```{r}
# End-to-end pipeline: demand_summed_by_cz → CZ-year metrics → align CZ20 & geometry → per-year GeoJSON
library(dplyr)
library(sf)

# ─────────────────────────────────────────────────────────────────────────────
# 0) Inputs expected in memory:
#   - demand_summed_by_cz           : tibble with SOC-level postings by cz_label & year (<=2025)
#   - county_cz_labels     : tibble/sf with at least: county (int FIPS), CZ (int), cz_label (chr)
#   - county_pop_ts        : tibble with at least: GEOID (chr FIPS), year (int), estimate (num)
#   - cz20                 : sf multipolygon with column CZ20 (int) + geometry
# Output:
#   - GeoJSON files: CZData_<year>.json (2010–2023)
#     fields: CZ20, YEAR, total_postings, airea_job_posting, pop, pct_green, per1000, geometry
# ─────────────────────────────────────────────────────────────────────────────

# 1) Standardize county↔CZ mapping (drop geometry; unify key names/types)
county_cz_labels_std <- county_cz_labels %>%
  st_drop_geometry() %>%
  transmute(
    county   = as.integer(county),
    CZ20     = as.integer(CZ),        # rename CZ → CZ20
    cz_label = as.character(cz_label)
  )

# 2) Standardize county-year population (convert FIPS "01001" → 1001 as integer)
county_pop_ts_std <- county_pop_ts %>%
  transmute(
    county = as.integer(GEOID),
    year   = year,
    population_estimate = estimate
  )

# 3) Population denominator for per1000:
#    compute total population by CZ20 + year; keep only years <= 2023
cz_pop_cz20_year <- county_pop_ts_std %>%
  left_join(county_cz_labels_std %>% select(county, CZ20), by = "county") %>%
  filter(!is.na(CZ20)) %>%
  group_by(CZ20, year) %>%
  summarise(cz_population = sum(population_estimate, na.rm = TRUE), .groups = "drop") %>%
  filter(year <= 2023)

# 4) Build a unique mapping cz_label → CZ20:
#    For each label, pick the CZ20 with the largest cumulative population (2010–2023)
cz_pop_by_cz20 <- county_pop_ts_std %>%
  left_join(county_cz_labels_std, by = "county") %>%
  filter(!is.na(CZ20), year <= 2023) %>%
  group_by(CZ20, cz_label, year) %>%
  summarise(cz_population = sum(population_estimate, na.rm = TRUE), .groups = "drop")

cz_label_to_cz20_unique <- cz_pop_by_cz20 %>%
  group_by(CZ20, cz_label) %>%
  summarise(pop_total = sum(cz_population, na.rm = TRUE), .groups = "drop") %>%
  filter(!is.na(cz_label)) %>%
  group_by(cz_label) %>%
  slice_max(order_by = pop_total, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(cz_label, CZ20)

# 5) Aggregate postings to CZ-year from demand_summed_by_cz (exclude 2024–2025)
cz_year <- demand_summed_by_cz %>%
  filter(year <= 2023) %>%
  group_by(cz_label, year) %>%
  summarise(
    total_postings    = sum(total_job_postings, na.rm = TRUE),
    airea_job_posting = sum(total_job_postings[airea == 1], na.rm = TRUE),
    .groups = "drop"
  )

# 6) Bring in CZ20, then join population by CZ20+year; compute metrics
cz_year_fixed <- cz_year %>%
  left_join(cz_label_to_cz20_unique, by = "cz_label") %>%
  filter(!is.na(CZ20)) %>%
  select(-dplyr::any_of("pop")) %>%                                  # avoid name conflicts
  left_join(cz_pop_cz20_year, by = c("CZ20", "year")) %>%
  mutate(
    pct_green = if_else(total_postings > 0,
                        100 * airea_job_posting / total_postings, NA_real_),  # percentage (0–100)
    per1000   = if_else(cz_population   > 0,
                        1000 * total_postings / cz_population,    NA_real_)   # jobs per 1,000
  ) %>%
  rename(pop = cz_population)

# (Optional) Quick QA
# stopifnot(!any(duplicated(cz_year_fixed[, c("CZ20", "year")])))
# summary(cz_year_fixed$pct_green); summary(cz_year_fixed$per1000)

# 7) Join geometry and export one GeoJSON per year (what the front-end expects)
cz20_clean <- cz20 %>%
  st_transform(4326) %>%
  st_make_valid() %>%
  st_zm(drop = TRUE, what = "ZM")

cz_sf_new <- cz20_clean %>%
  select(CZ20, geometry) %>%
  inner_join(cz_year_fixed, by = "CZ20") %>%
  rename(YEAR = year) %>%
  select(CZ20, YEAR,
         total_postings, airea_job_posting, pop, pct_green, per1000,
         geometry)

years <- sort(unique(cz_sf_new$YEAR))
for (y in years) {
  st_write(
    cz_sf_new %>% filter(YEAR == y),
    paste0("CZData_", y, ".json"),
    driver = "GeoJSON",
    delete_dsn = TRUE
  )
}


## NOTE: all the Json files should move to folder with mapbox.js (current project root: app/www)

```

