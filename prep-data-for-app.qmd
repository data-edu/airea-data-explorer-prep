---
title: "prep-data-for-app"
format: html
editor: visual
---

## loading

```{r}
library(tidyverse)
library(haven)
library(arrow)
library(tidycensus)
library(dtplyr)
```

## cz labels

```{r}
sff <- sf::read_sf("prep/CommutingZones2020_County_GIS_files/county20.shp") %>%
  as_tibble() %>%
  select(countycd = GEOID, CZ = CZ20, -geometry) %>%
  mutate(countycd = as.integer(countycd))

city_data <- read_csv("prep/us_cities_over_1000_with_county_fips.csv")

city_data <- city_data %>%
  mutate(countycd = as.integer(county_fips)) %>%
  select(city, countycd, population) %>%
  group_by(countycd) %>%
  slice_max(order_by = population, n = 1, with_ties = FALSE) %>%
  ungroup()

ratio_thresh <- 2      # how many times bigger the top city must be to stand alone
share_thresh <- 0.8    # how big (as a fraction of the top) a city must be to join the label

cz_labels <- city_data %>%
  inner_join(sff, by = "countycd") %>%    # bring in CZ for each county
  group_by(CZ) %>%
  summarise(
    cz_label = {
      df <- cur_data_all() %>% arrange(desc(population))
      if (nrow(df) >= 2 && df$population[1] >= ratio_thresh * df$population[2]) {
        df$city[1]
      } else {
        df$city[df$population >= share_thresh * df$population[1]] %>%
          paste(collapse = " & ")
      }
    },
    .groups = "drop"
  )

county_cz_labels <- sff %>%
  select(countycd, CZ) %>%
  left_join(cz_labels, by = "CZ") %>% 
  rename(county = countycd)

write_csv(county_cz_labels, "county_cz_labels.csv")
```

## supply

```{r}
supply_data <- read_dta("prep/ccrc_cip_comp_aire_6dig.dta")

supply_data <- supply_data %>% 
  select(instnm, inst_id = unitid,
         year, 
         state = State,
         tribal,
         rural,
         cip,
         cip_title = cip2020title,
         county = countycd,
         total_completions = cmplt_tot,
         airea_completions = inst_aire_cmplt_tot)

supply_data <- supply_data %>%
  mutate(county = as.integer(county)) %>% 
  left_join(county_cz_labels)

supply_data <- supply_data %>% 
  select(-CZ, -county)

supply_data %>% 
  arrow::write_parquet("prep/supply.parquet.gzip", compression = "gzip")
```

## demand data

```{r}
demand_data <- read_csv("prep/lightcast-soc-year-county-2025-02-24 7_23pm.csv")

# many are unknown
demand_data <- demand_data %>% 
  filter(!str_detect(COUNTY_NAME, "Unknown"))

demand_data <- demand_data %>% 
  rename(county = COUNTY)

demand_data <- demand_data %>% 
  left_join(county_cz_labels, by = "county") %>% 
  select(-CZ)

demand_meta_data <- read_dta("prep/full_soc.dta")

demand_meta_data <- demand_meta_data %>%
  mutate(aire_ind = as_factor(aire_ind)) %>%  # keep descriptive labels
  mutate(value = 1) %>%                       # mark presence
  pivot_wider(
    names_from = aire_ind, 
    values_from = value, 
    values_fill = list(value = 0)
  ) %>% 
  janitor::clean_names() %>% 
  rename(industry_non_airea = non_aire,
         industry_energy = energy,
         industry_infrastructure = infrastructure,
         industry_ag_nat_resources = agriculture_natural_resources)

demand_data <- demand_data %>% 
  rename(soc = SOC_CODE) %>% 
  left_join(demand_meta_data)

years <- 2010:2023

county_pop_data <- map_dfr(
  years,
  ~ get_acs(
    geography  = "county",
    variables  = "B01003_001",
    year       = .x,
    survey     = "acs5",
    cache_table= TRUE
  ) |>
    mutate(year = .x)
)

county_pop_ts <- county_pop_data %>% 
  select(-moe) %>% 
  select(COUNTY = GEOID, population_estimate = estimate, YEAR = year) %>% 
  rename(county = COUNTY) %>% 
  mutate(county = as.integer(county))

demand_data <- demand_data %>%
  left_join(county_pop_ts, by = c("county", "YEAR"))

demand_data <- demand_data %>% 
  select(county,
         cz_label,
         year = YEAR, 
         soc,
         soc_title = soc2018title, 
         job_posting_count = JOB_POSTING_COUNT,
         ed_req,
         airea = aire_relevant,
         population_estimate,
         contains("industry")
  )

demand_summed_by_cz <- lazy_dt(demand_data) %>%
  group_by(cz_label, year, soc) %>%
  summarise(
    mean_population    = mean(population_estimate, na.rm = TRUE),
    total_job_postings = sum(job_posting_count,   na.rm = TRUE),
    
    # grab first value of each “constant” column
    soc_title                = first(soc_title),
    ed_req                   = first(ed_req),
    airea                    = first(airea),
    across(starts_with("industry_"), first),
    
    .groups = "drop"
  ) %>%
  as_tibble() %>% 
  filter(!is.na(cz_label))

demand_summed_by_cz %>% 
  arrow::write_parquet("prep/demand.parquet.gzip", compression = "gzip")
```